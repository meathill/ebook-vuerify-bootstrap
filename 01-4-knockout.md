蒸汽动力 - Knockout，Angular1
========

MVC 是 Smalltalk 提出的编程模型，实际上，那个时期的概念跟今天相距甚远：主要输入设备是键盘，鼠标指针在屏幕上移动都需要开发者自己写，更没有“元素-点击事件”这种极其抽象的东西。所以它里面的 Model-View-Controller 不能用现在的概念去套。(感兴趣的同学可以去看下扩展阅读里头两篇文章。)

随着 UI 技术的发展，接下来出现的是 MVP 模型。它里面的 P（Presenter）已经是 UI 控件了，所以和 Web 技术非常接近。Backbone 就是这样架构的框架。

接下来，UI 技术进一步发展，HTML 这种标记语言如日中天，于是微软最早提出了 MVVM 的概念，并且将它应用在自家产品中。它的模式是这样的：

![MVVM 图示](./img/mvvm.png)
(图片来源：https://erazerbrecht.wordpress.com/2015/10/13/mvvm-entityframework/)

View 视图和 ViewModel 双向数据绑定，View 既是数据展示窗口，也是接受用户操作的输入来源。ViewModel 除了负责渲染逻辑以外，还负责全局数据管理，以及和真正的数据源 Model 进行交互。MVVM 非常吸引人，因为它在 MVP 的基础上又进行了一次抽象，所以开发维护效率巨高，代码量可能只有 MVP 的 1/10，但功能一致甚至更强。

最早在 Web 中引入这套模式的是 Knockout。用英语的句式来说：它是如此之早以至于它甚至支持 IE 6 和 Firefox 3.5……然而这也让它背上了沉重的历史包袱：

1. 它必须显式的声明数据绑定，显式到语法啰哩吧嗦
2. 赋值时必须使用 `.get(key)` `.set(key, val)` 这种语法，甚至 `a.get('key1').get('key2').get('key3').set('key4', val)` 这样

另一个尝试来自 Angular1。它不需要这么复杂的语法，而是采用“脏查询”的方式，即当某个可能导致页面重新渲染的操作产生后，检查所有备案过的变量，如果有改变的，就重新渲染。这种做法的问题就是慢，在运算能力充足的桌面电脑上感觉不明显，但是在移动端就会很慢。但是它的开发效率的确很高，在企业级占据霸主地位，几乎已经是事实标准。

这两个框架有些生不逢时，因为浏览器整体环境的限制，它们选择了不够完善的实现方案。于是随着时间发展，我们已经不需要它们了。